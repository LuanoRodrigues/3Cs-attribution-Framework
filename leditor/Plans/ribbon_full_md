### Plan format (required for plan-provided runs)

## Goal
Connect the config-driven ribbon so every tab (Ribbon registry, Home, Insert, Layout, Review, View) is loaded from its JSON, renders via the generic ribbon renderer, applies the correct CSS (shared + per-tab), and dispatches commands/state bindings deterministically from the JSON contract.

## Success criteria
- Ribbon boot loads `ribbon.json` and all `tabs[].source` JSON files without hard-coded per-tab definitions.
- Clicking each tab reliably renders its groups/clusters/controls from JSON (no missing/placeholder controls).
- Shared `ribbon.css` and per-tab CSS files are loaded and scoped; tab-specific selectors (e.g. `data-tab-id`) take effect.
- All control clicks dispatch the configured `command.id` with correct args/payload semantics.
- Menus/flyouts render into a portal attached to `document.body` and never clip.
- Collapse stages A/B/C update attributes deterministically and overflow routes controls per config.
- A deterministic validator reports PASS/FAIL for: registration, CSS loaded, wiring, portal, bindings, icon resolution.

## Constraints
- Must be config-driven: no heuristic hiding beyond configured collapse directives.
- Missing required fields must throw (dev + prod per repo policy); unknown control types must throw.
- DOM/class/attribute contracts must match the `domContracts` spec you provided (or be updated consistently).
- CSS must remain scoped to the ribbon and tab panels; no global leakage beyond intended tokens.
- Electron renderer compatibility: portal + fixed positioning + DPI scaling must work.
- Follow any repository rules in `AGENTS.md` (Codex must read it first and comply).
- Do not “paper over” missing bindings/types; crashes in dev are acceptable and preferred for correctness.

## Scope (exact file list)
Codex must inventory actual filenames first, then operate only on these targets under `leditor/src/ui/`:

Registration + loading
- `leditor/src/ui/ribbon.json`
- `leditor/src/ui/home.json`
- `leditor/src/ui/insert.json`
- `leditor/src/ui/layout_tab.json` (or `layout.json` if that is the tab file; must be confirmed)
- `leditor/src/ui/review.json` (must exist if Review is required)
- `leditor/src/ui/view.json`

Renderer / layout engine
- `leditor/src/ui/ribbon.ts`
- `leditor/src/ui/ribbon_layout.ts` (or equivalent file that handles stage/overflow/measure/portal)
- `leditor/src/ui/ribbon_config.ts` (create if missing; loader/parser/validation)
- `leditor/src/ui/controls/*` (create folder if missing; per-control renderers)
- `leditor/src/ui/menu_portal.ts` (create if missing; portal root management)
- `leditor/src/ui/command_dispatch.ts` (create if missing; centralized dispatch)
- `leditor/src/ui/icon_resolver.ts` (or existing `resolveIcon` location)
- `leditor/src/ui/ribbon_validate.ts` (create; deterministic validator)

CSS
- `leditor/src/ui/ribbon.css`
- `leditor/src/ui/home.css`
- `leditor/src/ui/insert.css`
- `leditor/src/ui/layout.css`
- `leditor/src/ui/review.css`
- `leditor/src/ui/view.css`

Build/entry (only if needed to ensure CSS imports execute)
- `leditor/src/ui/index.ts` (or the current UI entrypoint)

## Steps (numbered, with file paths and target symbols)

### Phase 0 — Repo preflight and contract reconciliation
1. Read `AGENTS.md` and repo build tooling (Vite/Webpack/TS config) to determine CSS loading strategy.
   - Files: `AGENTS.md`, `package.json`, `vite.config.*` / `webpack.config.*`, `tsconfig.json`
   - Output: decision: CSS via import vs runtime link injection.
2. Inventory `leditor/src/ui/` for actual filenames and reconcile naming mismatches:
   - Confirm existence of: `ribbon.json`, per-tab JSON files, and per-tab CSS files.
   - Confirm whether your provided “layoutId: ribbonLayout …” JSON is a layout-engine spec (not a tab config) and where it lives.
3. Confirm DOM contract in code matches CSS selectors:
   - Target symbols: `RibbonHost`, `RibbonTabStrip`, `RibbonPanel`, `renderTabPanel` (names may differ).
   - Ensure attributes exist: `data-tab-id`, `data-collapse-stage`, `data-ribbon-fixed-height`, `data-ribbon-tab-scroll`.

### Phase 1 — Registration: load ribbon + tab JSON deterministically
4. Implement/normalize a strict loader that hydrates `ribbon.json` plus every `tabs[].source`.
   - File: `leditor/src/ui/ribbon_config.ts` (create if missing)
   - Target symbols:
     - `loadRibbonRegistry(): RibbonRegistry`
     - `loadTabConfig(source: string): TabConfig`
     - `loadRibbonModel(): { registry, tabsById, orderedTabs }`
   - Required checks:
     - `registry.defaults.initialTabId` exists in `tabsById`
     - Each tab file’s `tabId` matches registry `tabId`
     - Duplicate `tabId` / `groupId` / `clusterId` / `controlId` → throw
5. Update ribbon entry to use the loader and render from loaded model.
   - File: `leditor/src/ui/ribbon.ts`
   - Target symbols:
     - `initRibbon()` or component constructor/`render()`
     - Replace any hard-coded tab list with `orderedTabs` from `loadRibbonModel()`

### Phase 2 — CSS application: shared + per-tab styles always loaded
6. Ensure shared + per-tab CSS are loaded exactly once, globally for the ribbon UI.
   - Option A (preferred): static imports
     - File: `leditor/src/ui/index.ts` (or `ribbon.ts` if that is the entry)
     - Add imports for:
       - `./ribbon.css`, `./home.css`, `./insert.css`, `./layout.css`, `./review.css`, `./view.css`
   - Option B: runtime injection (only if bundler cannot import CSS)
     - File: `leditor/src/ui/ribbon_styles.ts` (create)
     - Target symbol: `loadRibbonStyles(): void` appends `<link>` tags.
7. Enforce scoping attributes in DOM:
   - File: `leditor/src/ui/ribbon.ts`
   - Target symbols:
     - Panel container must set `data-tab-id="<activeTabId>"`
     - Host must set `data-collapse-stage="<A|B|C>"`
     - Host must set `data-ribbon-fixed-height="true|false"`
     - Root ribbon element must set `data-ribbon-tab-scroll="enabled|disabled"` (match your CSS)
   - This is required for selectors like:
     - `.leditor-ribbon-panel[data-tab-id="insert"] …`

### Phase 3 — Wiring: centralized command dispatch, state bindings, enabledWhen
8. Centralize command dispatch so every control type routes through one function.
   - File: `leditor/src/ui/command_dispatch.ts` (create if missing)
   - Target symbols:
     - `dispatchFromConfig(command, runtimePayload): void`
     - Merge precedence: `command.args` + `runtimePayload` (runtime overrides only for declared schema fields if you enforce schema)
9. Implement a strict control factory that maps JSON `control.type` → renderer.
   - File: `leditor/src/ui/controls/render_control.ts` (create)
   - Target symbol: `renderControl(control: ControlConfig, ctx: RenderCtx): HTMLElement|JSX`
   - Must support (at minimum) all types appearing in your JSON:
     - `button`, `toggleButton`, `splitButton`, `splitToggleButton`
     - `dropdown`, `combobox`, `spinnerDropdown`
     - `colorSplitButton`, `colorPicker`
     - `gallery`, `dialogLauncher`
     - `menuItem`, `menuToggle`, `separator`
     - `custom` widget support: `tableGridPicker`
   - Unknown type: throw (dev and per policy).
10. Implement state binding read and mixed-state rendering:
   - File: `leditor/src/ui/ribbon_state.ts` (or adapt existing store)
   - Target symbols:
     - `readBinding(bindingKey: string): any`
     - `isMixed(value): boolean` (based on your state encoding)
   - Render rules:
     - Toggle mixed → indeterminate UI (visual + aria)
     - Dropdown mixed → show placeholder (e.g., “—”)
11. Implement `enabledWhen` evaluation deterministically.
   - File: `leditor/src/ui/ribbon_state.ts` or `render_control.ts`
   - Rule:
     - If `enabledWhen` references a boolean binding → use it
     - If `enabledWhen` references a number (e.g., `pageCount`) → define explicit rule:
       - enabled if `pageCount > 0`
     - Codex must implement the same rule everywhere and document it in code comments (single place).

### Phase 4 — Menus/flyouts/portal: never clip and always return focus
12. Create/ensure portal root exists and is used for menus/flyouts.
   - File: `leditor/src/ui/menu_portal.ts` (create)
   - Target symbols:
     - `ensureRibbonPortal(): HTMLElement` creates `<div id="ribbon-portal">` in `document.body`
     - `renderIntoPortal(node, position): void`
13. Update menu rendering to use `position: fixed` and portal.
   - Files: `leditor/src/ui/controls/*` (dropdown, splitButton, colorPicker, gallery, custom widgets)
   - Target symbols:
     - `openMenu(invokerEl, menuConfig)`
     - Ensure outside-click + Escape close
     - Ensure focus returns to invoker on close

### Phase 5 — Collapse logic integration (A/B/C) and overflow routing
14. Wire collapse stage selection and DOM attribute updates to layout engine.
   - File: `leditor/src/ui/ribbon_layout.ts`
   - Target symbols:
     - `computeStage(availableWidthPx, activeTabConfig): "A"|"B"|"C"`
     - `applyStageDirectives(stage, tabConfig): RenderPlan`
     - `applyOverflow(plan): RenderPlan`
15. Ensure Stage B directives parse strictly and unknown directives throw.
   - File: `leditor/src/ui/ribbon_layout.ts`
   - Target symbol: `parseCollapseDirective(directive: string): Directive`
16. Ensure Stage C group collapse to group buttons + flyouts.
   - File: `leditor/src/ui/ribbon_layout.ts`
   - Target symbols:
     - `renderCollapsedGroupButton(group)`
     - `openGroupFlyout(group, invokerEl)`
   - Flyout must use portal and fixed positioning.

### Phase 6 — Tab-by-tab “connected” checklist (registration + css + wiring)
17. Home tab verification
   - File: `leditor/src/ui/home.json`, `leditor/src/ui/home.css`
   - Ensure:
     - Controls render: combobox, spinnerDropdown, splitToggleButton, palettes, gallery
     - Dispatch payloads:
       - `FontSize` uses `{ valuePx: number }`
       - `TextColor/HighlightColor` uses `{ value: string|null }`
18. Insert tab verification
   - File: `leditor/src/ui/insert.json`, `leditor/src/ui/insert.css`
   - Ensure:
     - `custom` widget: `tableGridPicker` renders in menu
     - SplitButton menus work for Pages/Tables/Illustrations/Media/Links/Symbols
     - `linkActive` state gates “Edit/Remove/Open/Copy Link”
19. Layout tab verification
   - File: `leditor/src/ui/layout_tab.json` (or confirmed tab file), `leditor/src/ui/layout.css`
   - Ensure:
     - Layout tab renders document layout controls and dispatches page metrics commands (size/orientation/margins)
     - Distinguish layout-engine spec JSON from layout-tab config JSON
20. Review tab verification
   - File: `leditor/src/ui/review.json`, `leditor/src/ui/review.css`
   - Ensure:
     - Review exists in `ribbon.json.tabs[]`
     - If not implemented, Codex must either (a) implement minimal valid Review tab JSON + CSS, or (b) remove Review references consistently. No dangling references.
21. View tab verification
   - File: `leditor/src/ui/view.json`, `leditor/src/ui/view.css`
   - Ensure:
     - Pagination dropdown dispatches `view.paginationMode.set`
     - Zoom dropdown dispatches `view.zoom.set` and zoom step buttons dispatch `view.zoom.step`
     - Toggle bindings: `showFormattingMarks`, `pageBoundaries`, `pageBreakMarks`, `ruler`, `fullscreen`

### Phase 7 — Deterministic validation harness
22. Add a validator that runs at ribbon initialization and produces a single PASS/FAIL report (or throws).
   - File: `leditor/src/ui/ribbon_validate.ts` (create)
   - Target symbols:
     - `validateRibbonModel(registry, tabsById): ValidationResult`
     - `validateIcons(tab): warnings`
     - `validateBindings(tab, globalStateContract): errors/warnings`
23. Add runtime probes for:
   - Portal exists and menu opens into it
   - Required DOM attributes present on host/panel
   - At least one per-tab CSS selector matches (e.g., computed style probe)

## Risk notes
- Risk: filename mismatch (`layout_tab.json` vs layout spec JSON) causes loader failures.
  - Detection: Phase 0 inventory; validator throws on missing `tabs[].source`.
- Risk: CSS not loaded due to build system differences.
  - Detection: runtime probe checks computed style differences; FAIL if unchanged.
- Risk: enabledWhen semantics inconsistent (e.g., numeric `pageCount` treated as boolean).
  - Detection: validator flags non-boolean enabledWhen keys; enforced rule documented and tested.
- Risk: menus clip because portal not used everywhere.
  - Detection: validator opens a menu per tab into portal; FAIL if menu not a child of `#ribbon-portal`.
- Risk: control type coverage incomplete (a JSON type not mapped).
  - Detection: loader/render throws immediately (desired in dev).
- Risk: duplicate IDs across tabs/groups cause event routing errors.
  - Detection: strict uniqueness checks in loader.

## Validation (commands or deterministic checks Codex will run itself)
Codex must run these locally in the repo after changes (adjust commands to repo tooling):
1. Typecheck/build
   - `npm run typecheck`
   - `npm run build`
2. Unit-ish deterministic checks (if no test runner exists, Codex must add a minimal script)
   - `npm run ribbon:validate` (Codex adds this script if missing) which:
     - loads `ribbon.json`
     - loads every tab JSON
     - validates IDs, types, bindings, icon keys
3. Runtime smoke (Electron/dev)
   - `npm run dev` (or `npm run electron:dev`)
   - Deterministic manual script Codex follows:
     - Open app → click each tab: Home/Insert/Layout/Review/View
     - For each tab open at least one dropdown/split menu
     - Confirm menu attaches under `#ribbon-portal`
     - Toggle one toggle control and confirm dispatch invocation logs/telemetry (if available)

## Rollback (explicit git commands)
- `git status`
- `git checkout -- leditor/src/ui/ribbon.ts`
- `git checkout -- leditor/src/ui/ribbon_layout.ts`
- `git checkout -- leditor/src/ui/ribbon.json`
- `git checkout -- leditor/src/ui/home.json leditor/src/ui/insert.json leditor/src/ui/layout_tab.json leditor/src/ui/review.json leditor/src/ui/view.json`
- `git checkout -- leditor/src/ui/ribbon.css leditor/src/ui/home.css leditor/src/ui/insert.css leditor/src/ui/layout.css leditor/src/ui/review.css leditor/src/ui/view.css`
- If many files changed: `git reset --hard HEAD`

## Progress
Phase 0 — Preflight and contract reconciliation
- Step 1: PASS
- Step 2: PASS
- Step 3: PASS

Phase 1 — Registration and JSON loading
- Step 4: PASS
- Step 5: PASS

Phase 2 — CSS application
- Step 6: PASS
- Step 7: PASS

Phase 3 — Wiring (commands/state/enabledWhen/control factory)
- Step 8: NOT STARTED
- Step 9: NOT STARTED
- Step 10: NOT STARTED
- Step 11: NOT STARTED

Phase 4 — Portal menus/flyouts
- Step 12: NOT STARTED
- Step 13: NOT STARTED

Phase 5 — Collapse/overflow integration
- Step 14: NOT STARTED
- Step 15: NOT STARTED
- Step 16: NOT STARTED

Phase 6 — Tab-by-tab connectivity verification
- Step 17: NOT STARTED
- Step 18: NOT STARTED
- Step 19: NOT STARTED
- Step 20: NOT STARTED
- Step 21: NOT STARTED

Phase 7 — Validator + runtime probes
- Step 22: NOT STARTED
- Step 23: NOT STARTED
