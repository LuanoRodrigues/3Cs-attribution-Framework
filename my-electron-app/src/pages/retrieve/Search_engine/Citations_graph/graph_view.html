<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />

<meta
  http-equiv="Content-Security-Policy"
  content="
    default-src 'self' data: blob: file:;
    script-src 'self' 'unsafe-inline' 'unsafe-eval' file:;
    script-src-elem 'self' 'unsafe-inline' 'unsafe-eval' file:;
    style-src 'self' 'unsafe-inline' file:;
    img-src 'self' data: blob: file:;
    connect-src 'self' https: file:;
  "
>



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Connected Papers–style Graph (Premium Standalone)</title>

  <!-- Qt WebChannel (optional, used for PNG export bridge) -->
<script src="./vendor/qwebchannel.js"></script>
  <script>
    (function(){
      try{
        if (typeof QWebChannel === "function" && window.qt && window.qt.webChannelTransport){
          new QWebChannel(qt.webChannelTransport, function(channel){
            window.qtBridge = channel.objects.qtBridge || null;
          });
        }
      }catch(_){}
    })();
  </script>

  <style>
    :root{
      --bg0:#f6f7fb;
      --bg1:#eef2f7;

      --panel: rgba(255,255,255,0.92);
      --panel2: rgba(255,255,255,0.84);
      --panel3: rgba(255,255,255,0.76);

      --border: rgba(15,23,42,0.12);
      --border2: rgba(15,23,42,0.08);

      --text:#0f172a;
      --muted:#64748b;
      --soft:#94a3b8;

      --shadow: rgba(0,0,0,0.10);

      --accent:#2563eb;
      --accent2:#1d4ed8;
      --accentSoft: rgba(37,99,235,0.14);

      --chipBg:#eef2ff;
      --chipText:#3730a3;

      --hot1:#1f3a5f;
      --hot2:#2b6cb0;
      --hot3:#f59e0b;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;

      --r: 14px;
      --r2: 12px;
    }

    *{ box-sizing:border-box; }

    html, body{
      height: 100%;
      margin: 0;
      overflow: hidden;
      font-family: var(--sans);
      background: linear-gradient(180deg, var(--bg0), var(--bg1));
      color: var(--text);
    }

    /* 2-panel app shell (graph + bottom bar) — keep the graph-adjacent panel; remove extreme right panel */
    #app{
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: 1fr 76px;
      grid-template-areas:
        "graph"
        "bar";
      gap: 0;
    }

    #graphWrap{
      grid-area: graph;
      position: relative;
      overflow: hidden;
    }

    #cy{
      position: absolute;
      inset: 0;
      background:
        radial-gradient(1100px 600px at 55% 45%, rgba(255,255,255,0.98) 0%, rgba(255,255,255,0.86) 45%, rgba(246,247,251,1) 100%),
        radial-gradient(900px 420px at 30% 65%, rgba(255,255,255,0.55) 0%, rgba(255,255,255,0.00) 65%),
        radial-gradient(760px 420px at 78% 58%, rgba(255,255,255,0.60) 0%, rgba(255,255,255,0.00) 70%);
    }

    #cy::after{
      content:"";
      position:absolute;
      inset:-2px;
      pointer-events:none;
      background: radial-gradient(1200px 800px at 50% 50%, rgba(0,0,0,0.00) 55%, rgba(0,0,0,0.03) 100%);
      mix-blend-mode: multiply;
    }

    /* premium top overlay bar inside graph */
    #topbar{
      position: absolute;
      top: 14px;
      left: 14px;
      right: 14px;
      z-index: 6;
      pointer-events: none;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
    }

    .topcard{
      pointer-events: auto;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--r);
      box-shadow: 0 16px 46px rgba(0,0,0,0.12);
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 10px;
      max-width: 70%;
      min-width: 320px;
    }

    #searchBox{
      display:flex;
      align-items:center;
      gap: 8px;
      width:100%;
      min-width: 0;
    }

    #searchInput{
      width: 360px;
      max-width: 46vw;
      border: 1px solid var(--border2);
      border-radius: 999px;
      padding: 9px 12px;
      font-size: 12px;
      outline: none;
      background: rgba(255,255,255,0.94);
      box-shadow: 0 10px 22px rgba(0,0,0,0.06);
    }
    #searchInput:focus{
      border-color: rgba(37,99,235,0.55);
      box-shadow: 0 0 0 3px rgba(37,99,235,0.15), 0 10px 22px rgba(0,0,0,0.06);
    }

    .btn{
      appearance: none;
      border: 1px solid rgba(15,23,42,0.14);
      background: rgba(255,255,255,0.96);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      cursor: pointer;
      font-size: 12px;
      line-height: 1;
      user-select: none;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 10px 22px rgba(0,0,0,0.06);
      white-space: nowrap;
    }
    .btn:hover{ background:#ffffff; border-color: rgba(37,99,235,0.25); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: var(--accent);
      border-color: var(--accent);
      color: #ffffff;
    }
    .btn.primary:hover{ background: var(--accent2); border-color: var(--accent2); }

    .btn.toggle{
      border-radius: 999px;
      padding: 8px 11px;
    }
    .btn.toggle.active{
      background: var(--accentSoft);
      border-color: rgba(37,99,235,0.35);
      color: var(--text);
    }

    /* topbar secondary controls (min-edge + help), replacing the removed keys strip */
    .pill{
      pointer-events: auto;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 999px;
      box-shadow: 0 16px 46px rgba(0,0,0,0.10);
      padding: 8px 10px;
      backdrop-filter: blur(10px);
      display: inline-flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }
    .pill .lbl{
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }
    .pill input[type="range"]{
      width: 150px;
      accent-color: var(--accent);
    }
    .pill output{
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      min-width: 34px;
      text-align: right;
    }

    /* toast + loading + error banner */
    #toast{
      position: absolute;
      left: 14px;
      bottom: 92px;
      z-index: 10;
      display: none;
      background: rgba(15,23,42,0.90);
      color: #ffffff;
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 12px;
      max-width: min(720px, 80vw);
      box-shadow: 0 18px 46px rgba(0,0,0,0.26);
      backdrop-filter: blur(8px);
      pointer-events: none;
    }

    #loading{
      position: absolute;
      top: 72px;
      left: 14px;
      z-index: 10;
      display: none;
      background: rgba(15,23,42,0.90);
      color: #fff;
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 12px;
      box-shadow: 0 18px 46px rgba(0,0,0,0.22);
      backdrop-filter: blur(8px);
      pointer-events: none;
    }

    #errBanner{
      display: none;
      position: absolute;
      top: 72px;
      right: 14px;
      z-index: 15;
      background: rgba(180,83,9,0.92);
      color: #fff;
      border-radius: 12px;
      padding: 10px 12px;
      max-width: min(560px, 60vw);
      box-shadow: 0 18px 46px rgba(0,0,0,0.22);
    }
    #errBanner b{ display:block; margin-bottom:6px; }

    /* LEFT PANEL (list) */
#leftPanel{
  position: absolute;
  top: 72px;
  left: 14px;
  z-index: 9;
  width: 360px;
  max-width: min(440px, 92vw);
  max-height: calc(100vh - 170px);
  background: rgba(255,255,255,0.94);
  border: 1px solid var(--border);
  border-radius: var(--r);
  box-shadow: 0 18px 52px rgba(0,0,0,0.16);
  backdrop-filter: blur(10px);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

#lpHeader{
  padding: 12px 12px 10px 12px;
  border-bottom: 1px solid rgba(15,23,42,0.10);
  background: rgba(249,250,251,0.82);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}

#lpTitle{
  font-size: 14px;
  font-weight: 800;
  color: #111827;
}

#lpSearch{
  padding: 10px 12px;
  border-bottom: 1px solid rgba(15,23,42,0.08);
}

#lpFilter{
  width: 100%;
  border: 1px solid var(--border2);
  border-radius: 999px;
  padding: 9px 12px;
  font-size: 12px;
  outline: none;
  background: rgba(255,255,255,0.96);
  box-shadow: 0 10px 22px rgba(0,0,0,0.05);
}
#lpFilter:focus{
  border-color: rgba(37,99,235,0.55);
  box-shadow: 0 0 0 3px rgba(37,99,235,0.15), 0 10px 22px rgba(0,0,0,0.05);
}

#lpList{
  padding: 8px;
  overflow: auto;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.lpItem{
  border: 1px solid rgba(15,23,42,0.10);
  background: rgba(255,255,255,0.95);
  border-radius: 12px;
  padding: 10px 10px;
  cursor: pointer;
  box-shadow: 0 10px 22px rgba(0,0,0,0.05);
}
.lpItem:hover{
  border-color: rgba(37,99,235,0.28);
}
.lpItem.active{
  border-color: rgba(37,99,235,0.62);
  box-shadow: 0 0 0 3px rgba(37,99,235,0.14), 0 10px 22px rgba(0,0,0,0.05);
}

.lpRow1{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
}
.lpMain{
  font-size: 12.5px;
  font-weight: 750;
  color: #111827;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.lpMeta{
  display:flex;
  gap: 6px;
  flex-wrap: wrap;
  margin-top: 7px;
}

/* minimise behaviour */
#leftPanel.collapsed{
  width: 44px;
  height: 44px;
  border-radius: 999px;
  overflow: hidden;
}
#leftPanel.collapsed #lpTitle,
#leftPanel.collapsed #lpSearch,
#leftPanel.collapsed #lpList,
#leftPanel.collapsed #lpAll,
#leftPanel.collapsed #lpPrior,
#leftPanel.collapsed #lpDeriv{
  display: none !important;
}
#leftPanel.collapsed #lpHeader{
  border-bottom: none;
  padding: 8px;
  background: rgba(255,255,255,0.92);
}
#leftPanel.collapsed #lpToggle{
  border-radius: 999px;
  padding: 10px 10px;
}

/* TOOLTIP CARD (replaces right panel) */
#tip{
  position: fixed;     /* fixed so it stays anchored relative to viewport */
  right: 14px;
  top: 88px;           /* JS will move it just under the Min edge pill */
  z-index: 10;
  width: 320px;
  max-width: min(420px, 92vw);
  background: rgba(255,255,255,0.94);
  border: 1px solid var(--border);
  border-radius: var(--r);
  box-shadow: 0 18px 52px rgba(0,0,0,0.16);
  backdrop-filter: blur(10px);
  overflow: hidden;
  display: none; /* shown on selection */
}

#tipHeader{
  padding: 12px 12px 10px 12px;
  border-bottom: 1px solid rgba(15,23,42,0.10);
  background: rgba(249,250,251,0.82);
}

#tipTitle{
  font-size: 13px;
  font-weight: 850;
  line-height: 1.2;
  color: #111827;
  margin-bottom: 8px;
}

#tipMeta{
  display:flex;
  flex-wrap: wrap;
  gap: 6px;
}

#tipActions{
  display: block;
  padding: 10px 12px 12px 12px;
}

#tipAbstract{
  width: 100%;
  display: block;

  border: 1px solid rgba(15,23,42,0.10);
  background: #ffffff;
  border-radius: 12px;

  padding: 10px 10px;
  margin: 0;

  font-family: var(--sans);
  font-size: 12.5px;
  line-height: 1.55;
  color: #111827;

  text-align: justify;
  text-justify: inter-word;

  white-space: normal;
  overflow-wrap: anywhere;
  word-break: break-word;

  max-height: 180px;
  overflow: auto;
}


/* responsive */
@media (max-width: 720px){
  #leftPanel{ top: 126px; }
  #tip{ right: 14px; left: 14px; width: auto; top: 78px; }
}


    #sideHeader{
      padding: 14px 14px 10px 14px;
      border-bottom: 1px solid rgba(15,23,42,0.10);
      background: rgba(249,250,251,0.82);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #sideTitle{
      margin: 0;
      font-size: 15px;
      font-weight: 850;
      letter-spacing: 0.1px;
      line-height: 1.15;
    }

    #sideMeta{
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .chip{
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: var(--chipBg);
      color: var(--chipText);
      padding: 3px 9px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid rgba(55,48,163,0.18);
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .chip.gray{
      background: rgba(243,244,246,0.92);
      color: var(--muted);
      border-color: rgba(0,0,0,0.06);
    }

    #sideBody{
      padding: 12px 14px;
      overflow: auto;
      font-size: 12.5px;
      line-height: 1.5;
      color: #374151;
      flex: 1;
    }

    #sideBody h3{
      margin: 16px 0 8px 0;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #111827;
    }

    .muted{ color: var(--muted); }

    .kv{
      display: grid;
      grid-template-columns: 92px 1fr;
      gap: 8px 10px;
      align-items: start;
    }
    .k{ color: var(--muted); font-size: 11.5px; padding-top: 1px; }
    .v{ color: #111827; overflow-wrap: anywhere; }

    .link{
      color: var(--accent);
      text-decoration: none;
      word-break: break-word;
    }
    .link:hover{ text-decoration: underline; }

    #abstractBox{
      border: 1px solid rgba(15,23,42,0.10);
      background: #ffffff;
      border-radius: 12px;
      padding: 10px;
      color: #111827;
    }

    #abstractText{
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
    }

    #sideActions{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 12px;
    }

    .hr{
      border: none;
      border-top: 1px solid rgba(15,23,42,0.10);
      margin: 12px 0;
    }

    /* bottom bar */
    #bar{
      grid-area: bar;
      background: rgba(255,255,255,0.92);
      border-top: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 12px;
      gap: 10px;
      backdrop-filter: blur(8px);
    }

  #barLeft{
  display:flex;
  align-items:center;
  gap: 10px;
  min-width: 0;
  flex: 1 1 auto;
  overflow: hidden;
}


    #legend{
      display:flex;
      align-items:center;
      gap: 10px;
      color: var(--muted);
      font-size: 12px;
      min-width: 0;
    }

    #grad{
      width: 220px;
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(90deg, var(--hot1) 0%, var(--hot2) 45%, var(--hot3) 100%);
      border: 1px solid rgba(15,23,42,0.10);
      flex: 0 0 auto;
    }

    #stats{
      display: inline-flex;
      align-items: center;
      gap: 10px;
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 52vw;
    }

    .stat{
      padding: 6px 10px;
      border: 1px solid rgba(15,23,42,0.12);
      border-radius: 999px;
      background: #ffffff;
      color: #111827;
      font-size: 12px;
      box-shadow: 0 10px 22px rgba(0,0,0,0.05);
    }

  #barRight{
  display:flex;
  align-items:center;
  justify-content:flex-end;
  gap: 8px;

  flex-wrap: nowrap;
  overflow-x: auto;
  overflow-y: hidden;
  max-width: 60vw;

  -webkit-overflow-scrolling: touch;
  scrollbar-width: thin;
}

#barRight .btn{
  flex: 0 0 auto;
}


    @media (max-width: 980px){
      #searchInput{ width: 260px; }
      #grad{ width: 160px; }
      .topcard{ max-width: 72%; }
      #side{
        width: 340px;
        top: 74px;
      }
      .pill input[type="range"]{ width: 120px; }
    }

    @media (max-width: 720px){
      #side{
        right: 14px;
        left: 14px;
        width: auto;
        max-width: none;
        top: 126px;
        max-height: calc(100vh - 230px);
      }
      .pill{ display:none; }
      #searchInput{ max-width: 42vw; }
    }
  </style>

    <!-- Cytoscape + layouts (local bundle; no CDN) -->
<script src="./vendor/cytoscape.min.js"></script>

<script src="./vendor/cola.min.js"></script>
<script src="./vendor/cytoscape-cola.min.js"></script>

<script src="./vendor/layout-base.js"></script>
<script src="./vendor/cose-base.js"></script>
<script src="./vendor/cytoscape-fcose.js"></script>



<script>
(function(){
  function probe(name, ok){
    console.log("[PROBE]", name, ok ? "OK" : "MISSING");
    if (!ok){
      const b = document.getElementById("errBanner");
      if (b) b.style.display = "block";
    }
  }
  probe("cytoscape", typeof window.cytoscape === "function");
  probe("cytoscapeCola", !!(window.cytoscapeCola || window.cola));
  probe("fcose", !!(window.fcose || window.cytoscapeFcose || window.cytoscapeFCOSE));
})();
</script>
<script>
(function(){
  "use strict";

  function showErr(msg){
    const b = document.getElementById("errBanner");
    if (b) b.style.display = "block";
    console.error(msg);
  }

  const cyFn = window.cytoscape;
  if (typeof cyFn !== "function"){
    showErr("[INIT] cytoscape not loaded. Check ./vendor/cytoscape.min.js path.");
    window.layoutPreferred = "cose";
    return;
  }

  // Correct UMD globals:
  // - webcola (engine): window.cola
  // - cytoscape-cola (plugin): window.cytoscapeCola
  // - cytoscape-fcose (plugin): window.fcose
  const colaPlugin  = (typeof window.cytoscapeCola === "function") ? window.cytoscapeCola : null;
  const fcosePlugin = (typeof window.fcose === "function") ? window.fcose : null;

  let hasCola = false;
  let hasFcose = false;

  if (colaPlugin){
    try{
      cyFn.use(colaPlugin);
      hasCola = true;
    }catch(e){
      console.warn("[INIT] cytoscape-cola registration failed:", e);
    }
  }

  if (fcosePlugin){
    try{
      cyFn.use(fcosePlugin);
      hasFcose = true;
    }catch(e){
      console.warn("[INIT] fcose registration failed:", e);
    }
  }

  // Prefer cola if available; else fcose; else cose.
  window.layoutPreferred = hasCola ? "cola" : (hasFcose ? "fcose" : "cose");
  console.log("[INIT] cytoscape OK. hasCola=", hasCola, "hasFcose=", hasFcose, "layoutPreferred=", window.layoutPreferred);
})();
</script>


</head>

<body>
  <div id="app">
<div id="graphWrap">
  <div id="cy"></div>

  <div id="topbar">
    <div class="topcard" style="flex:1;">
      <div id="searchBox">
        <input id="searchInput" type="text" placeholder="Search node titles / authors (press Enter)" />
        <button class="btn" id="btnSearch">Search</button>
        <button class="btn" id="btnClearSearch">Clear</button>
      </div>
    </div>

    <div class="pill" aria-label="Minimum edge weight">
      <span class="lbl">Min edge</span>
      <input id="minEdge" type="range" min="0" max="100" value="20" />
      <output id="minEdgeOut">0.20</output>
      <span style="width:1px;height:18px;background:rgba(15,23,42,0.10);"></span>
      <button class="btn" id="btnHelp">Help</button>
    </div>
  </div>

  <aside id="leftPanel" class="collapsed">
    <div id="lpHeader">
      <div id="lpTitle">Papers</div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button class="btn toggle active" id="lpAll">All</button>
        <button class="btn toggle" id="lpPrior">Prior</button>
        <button class="btn toggle" id="lpDeriv">Derivative</button>
        <button class="btn" id="lpToggle" title="Minimise / expand">▸</button>
      </div>
    </div>

    <div id="lpSearch">
      <input id="lpFilter" type="text" placeholder="Filter titles / authors" />
    </div>

    <div id="lpList" role="listbox" aria-label="Paper list"></div>
  </aside>

  <div id="loading">Building graph…</div>
  <div id="toast"></div>

  <div id="errBanner">
    <b>Graph renderer failed to initialise.</b>
    <div style="font-size:11.5px;">
      If you see “Cytoscape not loaded”, your local bundle is not loading. Verify:
      (1) ./vendor/cytoscape.min.js exists beside this HTML,
      (2) CSP allows file: scripts,
      (3) Qt WebEngine allows local file access (LocalContentCanAccessFileUrls/RemoteUrls).
    </div>
  </div>

  <div id="tip" aria-live="polite">
    <div id="tipHeader">
      <div id="tipTitle">Select a paper</div>
      <div id="tipMeta"></div>
    </div>
    <div id="tipActions">
      <div id="tipAbstract" class="muted">(no abstract)</div>
    </div>
  </div>
</div>

<div id="bar">
  <div id="barLeft">
    <div id="legend">
      <span id="minYear">Old</span>
      <div id="grad"></div>
      <span id="maxYear">New</span>
    </div>
    <div id="stats"></div>
  </div>

  <div id="barRight">
    <button class="btn" id="btnFit">Fit</button>
    <button class="btn" id="btnRelayout">Re-layout</button>

    <button class="btn toggle active" id="btnAll">All</button>
    <button class="btn toggle" id="btnPrior">Prior</button>
    <button class="btn toggle" id="btnDeriv">Derivative</button>

    <button class="btn toggle" id="btnScope" title="Graph universe: Local = within your results; Global = expand via Semantic Scholar refs/cites">Local</button>

    <button class="btn primary" id="btnExportPng">Export PNG</button>
    <button class="btn" id="btnReset">Reset</button>
  </div>
</div>




<script>
"use strict";
if (typeof toast !== "function"){
  window.toast = (m, ms) => ui_toast(m, ms);
}
if (typeof setLoading !== "function"){
  window.setLoading = (on, msg) => ui_state(msg || "", !!on);
}
if (typeof uiError !== "function"){
  window.uiError = (on) => ui_error(!!on, on ? "Error." : "");
}


function connectQtBridge(){
  if (window.qtBridge && typeof window.qtBridge === "object") return;

  window.qtBridge = {
    openUrl: (url) => { try{ window.open(String(url), "_blank", "noopener,noreferrer"); }catch(_){ } },
    savePngDataUrl: (dataUrl) => {
      try{
        const a = document.createElement("a");
        a.href = String(dataUrl || "");
        a.download = "graph.png";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }catch(_){ }
    }
  };
}

function ui_make(){
  if (document.getElementById("ui_toast")) return;

  const toast = document.createElement("div");
  toast.id = "ui_toast";
  toast.style.position = "fixed";
  toast.style.left = "14px";
  toast.style.bottom = "14px";
  toast.style.zIndex = "99999";
  toast.style.maxWidth = "560px";
  toast.style.padding = "10px 12px";
  toast.style.borderRadius = "12px";
  toast.style.background = "rgba(15,23,42,0.92)";
  toast.style.color = "#ffffff";
  toast.style.fontFamily = "system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif";
  toast.style.fontSize = "13px";
  toast.style.lineHeight = "1.3";
  toast.style.display = "none";
  document.body.appendChild(toast);

  const state = document.createElement("div");
  state.id = "ui_state";
  state.style.position = "fixed";
  state.style.right = "14px";
  state.style.top = "14px";
  state.style.zIndex = "99999";
  state.style.padding = "8px 10px";
  state.style.borderRadius = "12px";
  state.style.background = "rgba(255,255,255,0.92)";
  state.style.border = "1px solid rgba(15,23,42,0.12)";
  state.style.color = "#0f172a";
  state.style.fontFamily = "system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif";
  state.style.fontSize = "12.5px";
  state.style.display = "none";
  document.body.appendChild(state);
}

let _toastTimer = 0;
function ui_toast(msg, ms){
  const el = document.getElementById("ui_toast");
  if (!el) return;
  window.clearTimeout(_toastTimer);
  const t = String(msg || "");
  if (!t){
    el.style.display = "none";
    return;
  }
  el.textContent = t;
  el.style.display = "block";
  _toastTimer = window.setTimeout(() => { el.style.display = "none"; }, Math.max(250, Number(ms) || 900));
}

function ui_state(msg, busy){
  const el = document.getElementById("ui_state");
  if (!el) return;
  const t = String(msg || "");
  if (!t){
    el.style.display = "none";
    return;
  }
  el.textContent = t;
  el.style.display = "block";
  el.style.opacity = busy ? "1" : "0.88";
}

function ui_error(show, msg){
  const t = String(msg || "");
  if (show && t) ui_toast(t, 1600);
}

function registerExtensions(){}

</script>

<script>
  "use strict";

  // ------------------------------------------------------------
  // FAST + PREMIUM: tuned for Qt WebEngine (QWebEngineView)
  // ------------------------------------------------------------
let cy = null;

let payloadCache = {};
let payloadCacheFull = null;
let priorSet = new Set();
let derivSet = new Set();

function _rebuild_sets_from_payload(p){
  priorSet = new Set((p && p.priorIds) ? p.priorIds.map(String) : []);
  derivSet = new Set((p && p.derivativeIds) ? p.derivativeIds.map(String) : []);
}

function _node_map_from_payload(p){
  const m = new Map();
  for (const n of (p && p.nodes) ? p.nodes : []){
    if (!n || !n.data) continue;
    const id = String(n.data.id || "");
    if (!id) continue;
    m.set(id, n);
  }
  return m;
}

function _local_focus_payload(full, focus_id){
  const sid = String(focus_id || "");
  if (!full || !sid) return null;

  const nodes = full.nodes || [];
  const edges = full.edges || [];
  const node_map = _node_map_from_payload(full);

  if (!node_map.has(sid)) return null;

  const keep_ids = new Set([sid]);

  for (const e of edges){
    const d = e && e.data ? e.data : null;
    if (!d) continue;
    const a = String(d.source || "");
    const b = String(d.target || "");
    if (!a || !b) continue;

    if (a === sid){
      keep_ids.add(b);
    }else if (b === sid){
      keep_ids.add(a);
    }
  }

  const keep_nodes = [];
  for (const id of keep_ids){
    const n = node_map.get(id);
    if (n) keep_nodes.push(n);
  }

  const keep_edges = [];
  for (const e of edges){
    const d = e && e.data ? e.data : null;
    if (!d) continue;
    const a = String(d.source || "");
    const b = String(d.target || "");
    if (keep_ids.has(a) && keep_ids.has(b)) keep_edges.push(e);
  }

  const seed_id = sid;

  const prior_ids = [];
  const deriv_ids = [];

  const seed_year = (() => {
    const n = node_map.get(seed_id);
    const y = n && n.data ? n.data.year : null;
    const yy = parseInt(y, 10);
    return Number.isFinite(yy) && yy > 0 ? yy : null;
  })();

  if (seed_year != null){
    for (const n of keep_nodes){
      const d = n && n.data ? n.data : null;
      if (!d) continue;
      const nid = String(d.id || "");
      if (!nid || nid === seed_id) continue;
      const yy = parseInt(d.year, 10);
      if (!Number.isFinite(yy) || yy <= 0) continue;
      if (yy < seed_year) prior_ids.push(nid);
      else if (yy > seed_year) deriv_ids.push(nid);
    }
  }

  return {
    seedId: seed_id,
    priorIds: prior_ids,
    derivativeIds: deriv_ids,
    scope: "local",
    build_ms: 0,
    nodes: keep_nodes,
    edges: keep_edges,
  };
}

function _apply_scope_after_selection(id){
  const sid = String(id || "");
  if (!sid) return;

  if (graphScope === "global"){
    if (payloadCacheFull){
      render(payloadCacheFull);
      if (selectedId) selectNode(selectedId, false);
    }
    return;
  }

  if (!payloadCacheFull) return;

  const lp = _local_focus_payload(payloadCacheFull, sid);
  if (!lp) return;

  render(lp);
  selectNode(sid, false);
}


let currentMode = "all";
let selectedId = "";
const pinned = new Set();

let graphScope = "global";

function loadScope(){
  try{
    const raw = window.localStorage.getItem("graph.scope");
    const v = String(raw || "").toLowerCase().trim();
    if (v === "local" || v === "global") return v;
  }catch(_){}
  return "global";
}


function saveScope(v){
  try{ window.localStorage.setItem("graph.scope", v); }catch(_){}
}
function setScopeUi(v){
  graphScope = (v === "global") ? "global" : "local";
  const b = document.getElementById("btnScope");
  if (b){
    b.textContent = (graphScope === "global") ? "Global" : "Local";
    b.classList.toggle("active", graphScope === "global");
  }
}

function setScope(v){
  const next = (String(v || "").toLowerCase() === "global") ? "global" : "local";
  saveScope(next);
  setScopeUi(next);

  console.log("SCOPE_SET:" + next);

  if (next === "global"){
    if (payloadCacheFull){
      render(payloadCacheFull);
      if (selectedId) selectNode(selectedId, false);
    }
  }else{
    if (selectedId){
      _apply_scope_after_selection(selectedId);
    }
  }

  toast(`Scope: ${next}`, 800);
}



// left list panel state
let listMode = "all";          // "all" | "prior" | "derivative"
let listFilter = "";


  let lastSearchHits = [];
  let lastSearchIndex = -1;

  let _viewportTimer = 0;
  let _isViewportBusy = false;
function clamp01(x){ return x < 0 ? 0 : (x > 1 ? 1 : x); }
function safeInt(v, d){
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : d;
}
function safeNum(v, d){
  const n = parseFloat(v);
  return Number.isFinite(n) ? n : d;
}

function _hash32(s){
  const str = String(s || "");
  let h = 2166136261;
  for (let i = 0; i < str.length; i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return (h >>> 0);
}

function _hex2rgb(hex){
  const h = String(hex || "").replace("#", "").trim();
  if (h.length !== 6) return { r: 120, g: 120, b: 120 };
  const r = parseInt(h.slice(0,2), 16);
  const g = parseInt(h.slice(2,4), 16);
  const b = parseInt(h.slice(4,6), 16);
  return { r: Number.isFinite(r) ? r : 120, g: Number.isFinite(g) ? g : 120, b: Number.isFinite(b) ? b : 120 };
}

function _rgb2hex(r,g,b){
  const rr = Math.max(0, Math.min(255, Math.round(r)));
  const gg = Math.max(0, Math.min(255, Math.round(g)));
  const bb = Math.max(0, Math.min(255, Math.round(b)));
  const to2 = (n) => n.toString(16).padStart(2, "0");
  return "#" + to2(rr) + to2(gg) + to2(bb);
}

function lightenHex(hex, amt01){
  const t = clamp01(Number(amt01) || 0);
  const c = _hex2rgb(hex);
  return _rgb2hex(
    c.r + (255 - c.r) * t,
    c.g + (255 - c.g) * t,
    c.b + (255 - c.b) * t
  );
}

const NODE_PALETTE = [
  "#0ea5e9", "#22c55e", "#a855f7", "#f97316",
  "#ef4444", "#14b8a6", "#eab308", "#6366f1",
  "#f43f5e", "#84cc16"
];
function pickNodeBaseColor(d){
  const fos = Array.isArray(d && d.fieldsOfStudy) && d.fieldsOfStudy.length ? String(d.fieldsOfStudy[0] || "") : "";
  const title = String((d && (d._title || d.title || d.label)) || "").trim();
  const authors = authorsToString(d && d.authors);
  const id = String((d && d.id) || "").trim();

  const key = [fos, title, authors, id].filter(Boolean).join("|") || id || title || "x";
  const idx = _hash32(key) % NODE_PALETTE.length;
  return NODE_PALETTE[idx];
}


  function firstAuthorName(authorsStr){
  const s = String(authorsStr || "").trim();
  if (!s) return "";
  return s.split(",")[0].trim(); // assumes "A. One, B. Two"
}

function initialsFromName(name){
  const parts = String(name || "").trim().split(/\s+/).filter(Boolean);
  if (!parts.length) return "";
  const a = parts[0][0] || "";
  const b = (parts.length > 1 ? parts[parts.length - 1][0] : "") || "";
  return (a + b).toUpperCase();
}
function svgAvatarDataUri(initials, baseHex){
  const txt = initials || "•";
  const base = String(baseHex || "#e5e7eb").trim();
  const pale = lightenHex(base, 0.78);

  const svg =
`<svg xmlns="http://www.w3.org/2000/svg" width="96" height="96">
  <defs>
    <radialGradient id="g" cx="35%" cy="30%" r="80%">
      <stop offset="0%" stop-color="#ffffff"/>
      <stop offset="100%" stop-color="${pale}"/>
    </radialGradient>
  </defs>
  <circle cx="48" cy="48" r="47" fill="url(#g)" />
  <text x="50%" y="54%" dominant-baseline="middle" text-anchor="middle"
        font-family="system-ui, -apple-system, Segoe UI, Roboto, Arial"
        font-size="34" font-weight="700" fill="#0f172a">${txt}</text>
</svg>`;
  return "data:image/svg+xml;utf8," + encodeURIComponent(svg);
}


  function normalizeText(s){
    return String(s || "").toLowerCase().trim();
  }

  function setLoading(on, msg){
    const el = document.getElementById("loading");
    if (!el) return;
    el.textContent = msg || "Working…";
    el.style.display = on ? "block" : "none";
  }

  function toast(msg, ms){
    const el = document.getElementById("toast");
    if (!el) return;
    el.textContent = String(msg || "");
    el.style.display = msg ? "block" : "none";
    if (msg && ms){
      window.clearTimeout(el._t);
      el._t = window.setTimeout(() => { el.style.display = "none"; }, ms);
    }
  }

  function uiError(on){
    const el = document.getElementById("errBanner");
    if (!el) return;
    el.style.display = on ? "block" : "none";
  }

  function pickNodeDataById(id){
    const nodes = payloadCache.nodes || [];
    const sid = String(id || "");
    for (const n of nodes){
      const d = (n && n.data) ? n.data : null;
      if (d && String(d.id) === sid) return d;
    }
    return null;
  }

  function updateYearLegendFromNodes(nodes){
    const years = [];
    for (const n of nodes || []){
      const d = (n && n.data) ? n.data : null;
      const y = d ? safeInt(d.year, 0) : 0;
      if (y > 0) years.push(y);
    }

    let yMin = years.length ? Math.min.apply(null, years) : 2000;
    let yMax = years.length ? Math.max.apply(null, years) : 2025;
    if (yMax === yMin) yMax = yMin + 1;

    const elMin = document.getElementById("minYear");
    const elMax = document.getElementById("maxYear");
    if (elMin) elMin.textContent = String(yMin);
    if (elMax) elMax.textContent = String(yMax);

    payloadCache._yMin = yMin;
    payloadCache._yMax = yMax;
  }

  function yearColor(yy){
    const y = safeInt(yy, 0);
    const yMin = safeInt(payloadCache._yMin, 2000);
    const yMax = safeInt(payloadCache._yMax, 2025);
    if (!y || yMin === yMax) return "rgb(43,108,176)";

    const t = clamp01((y - yMin) / (yMax - yMin));

    let r, g, b;
    if (t < 0.5){
      const u = t * 2;
      r = 31 + (43 - 31) * u;
      g = 58 + (108 - 58) * u;
      b = 95 + (176 - 95) * u;
    }else{
      const u = (t - 0.5) * 2;
      r = 43 + (245 - 43) * u;
      g = 108 + (158 - 108) * u;
      b = 176 + (11 - 176) * u;
    }
    return "rgb(" + Math.round(r) + "," + Math.round(g) + "," + Math.round(b) + ")";
  }

  function buildStats(payload){
    const n = (payload.nodes || []).length;
    const e = (payload.edges || []).length;
    const ms = safeInt(payload.build_ms, 0);
    return `<span class="stat">${n} nodes</span><span class="stat">${e} edges</span><span class="stat">${ms} ms</span>`;
  }

  function setStats(html){
    const el = document.getElementById("stats");
    if (el) el.innerHTML = html || "";
  }

  function setModeButtons(mode){
    const bAll = document.getElementById("btnAll");
    const bPrior = document.getElementById("btnPrior");
    const bDeriv = document.getElementById("btnDeriv");

    for (const [b, m] of [[bAll,"all"],[bPrior,"prior"],[bDeriv,"derivative"]]){
      if (!b) continue;
      b.classList.toggle("active", mode === m);
    }
  }

  // ------------------------------------------------------------
  // Premium spotlight model (hover vs locked selection)
  // ------------------------------------------------------------
  function clearSpotlight(){
    if (!cy) return;
    cy.batch(() => {
      cy.elements().removeClass("dim");
      cy.elements().removeClass("hoverNode");
      cy.edges().removeClass("hoverEdge");
    });
  }

function spotlightNode(node){
  if (!cy || !node) return;
  cy.batch(() => {
    cy.elements().removeClass("hoverNode");
    cy.edges().removeClass("hoverEdge");

    const nbrs = node.closedNeighborhood();
    cy.elements().addClass("dim");
    nbrs.removeClass("dim");

    node.addClass("hoverNode");
    node.connectedEdges().addClass("hoverEdge");
  });
}


function spotlightEdge(edge){
  if (!cy || !edge) return;
  cy.batch(() => {
    cy.elements().removeClass("hoverNode");
    cy.edges().removeClass("hoverEdge");

    cy.elements().addClass("dim");
    edge.removeClass("dim").addClass("hoverEdge");
    edge.connectedNodes().removeClass("dim").addClass("hoverNode");
  });
}


  // ------------------------------------------------------------
  // Mode filtering (prior/derivative/pins) – optimised
  // ------------------------------------------------------------
  function applyMode(){
    if (!cy) return;

    if (currentMode === "all"){
      cy.batch(() => {
        cy.nodes().removeClass("dim");
        cy.edges().removeClass("dim");
      });
      return;
    }

    const keepSet = (currentMode === "prior") ? priorSet : derivSet;

    // One pass, no repeated getElementById
    cy.batch(() => {
      cy.nodes().forEach(n => {
        const id = n.id();
        const isSeed = !!n.data("isSeed");
        const keep = isSeed || keepSet.has(id) || pinned.has(id);
        n.toggleClass("dim", !keep);
      });

      cy.edges().forEach(e => {
        const s = e.source();
        const t = e.target();
        const keepEdge = !s.hasClass("dim") && !t.hasClass("dim");
        e.toggleClass("dim", !keepEdge);
      });
    });
  }
function escapeHtml(s){
  return String(s || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}
function updateTip(d){
  const tip = document.getElementById("tip");
  const tTitle = document.getElementById("tipTitle");
  const tMeta = document.getElementById("tipMeta");
  const tAbs = document.getElementById("tipAbstract");
  if (!tip || !tTitle || !tMeta || !tAbs) return;

  if (!d){
    tip.style.display = "none";
    return;
  }

  const pid = String(d.id || "");
  const flags = [];
  if (d.isSeed === true || pid === String(payloadCache.seedId || "")) flags.push("SEED");
  if (priorSet.has(pid)) flags.push("PRIOR_WORK");
  if (derivSet.has(pid)) flags.push("DERIVATIVE_WORK");
  if (pinned.has(pid)) flags.push("PINNED");

  const yearVal = (d.year == null || String(d.year).trim() === "") ? -1 : safeInt(d.year, -1);

  const citesVal = (d.citations == null && d.citationCount == null)
    ? -1
    : safeInt((d.citations != null ? d.citations : d.citationCount), -1);

  const refsVal  = (d.referenceCount == null) ? -1 : safeInt(d.referenceCount, -1);
  const inflVal  = (d.influentialCitationCount == null) ? -1 : safeInt(d.influentialCitationCount, -1);

  const yearChip = (yearVal >= 0) ? `<span class="chip gray">${String(yearVal)}</span>` : `<span class="chip gray">Year n/a</span>`;
  const citeChip = (citesVal >= 0) ? `<span class="chip gray">cites ${String(citesVal)}</span>` : `<span class="chip gray">cites n/a</span>`;
  const refChip  = (refsVal >= 0) ? `<span class="chip gray">refs ${String(refsVal)}</span>` : `<span class="chip gray">refs n/a</span>`;
  const infChip  = (inflVal >= 0) ? `<span class="chip gray">influential ${String(inflVal)}</span>` : `<span class="chip gray">influential n/a</span>`;

  const flagChips = flags.length
    ? flags.map(f => `<span class="chip">${escapeHtml(f)}</span>`).join("")
    : `<span class="chip gray">No flags</span>`;

  const titleText = String(d._title || d.title || d.label || pid || "Untitled").trim();
  tTitle.textContent = titleText || pid || "Untitled";

  const venue = String(d.venue || (d.publicationVenue && d.publicationVenue.name) || "").trim();
  const doi = String(d.doi || "").trim();
  const url = String(d.url || "").trim();

  let authorsStr = String(d.authors_str || d.authors || "").trim();
  if (!authorsStr && Array.isArray(d.authors_list)){
    authorsStr = d.authors_list
      .map(a => (a && typeof a === "object") ? String(a.name || "").trim() : String(a || "").trim())
      .filter(Boolean)
      .join(", ");
  }
  if (!authorsStr && Array.isArray(d.authors)){
    authorsStr = d.authors
      .map(a => (a && typeof a === "object") ? String(a.name || "").trim() : String(a || "").trim())
      .filter(Boolean)
      .join(", ");
  }

  const biblio = [];
  if (authorsStr) biblio.push(`<div><b>Authors:</b> ${escapeHtml(authorsStr)}</div>`);
  if (venue) biblio.push(`<div><b>Venue:</b> ${escapeHtml(venue)}</div>`);
  if (doi) biblio.push(`<div><b>DOI:</b> ${escapeHtml(doi)}</div>`);
  if (url) biblio.push(`<div><b>URL:</b> <a href="#" data-open="${escapeHtml(url)}">${escapeHtml(url)}</a></div>`);

  const extra = [];
  if (Array.isArray(d.fieldsOfStudy) && d.fieldsOfStudy.length){
    extra.push(
      `<div><b>Fields:</b> ${escapeHtml(d.fieldsOfStudy.slice(0, 6).join(", "))}${d.fieldsOfStudy.length > 6 ? "…" : ""}</div>`
    );
  }
  const oa = (d.isOpenAccess === true) ? "Open access" : (d.isOpenAccess === false ? "Not open access" : "");
  if (oa) extra.push(`<div><b>OA:</b> ${escapeHtml(oa)}</div>`);
  const pubDate = String(d.publicationDate || "").trim();
  if (pubDate) extra.push(`<div><b>Published:</b> ${escapeHtml(pubDate)}</div>`);

  tMeta.innerHTML = (
    `${flagChips}${yearChip}${citeChip}${refChip}${infChip}` +
    (biblio.length ? `<div style="margin-top:8px">${biblio.join("")}</div>` : "") +
    (extra.length ? `<div style="margin-top:6px" class="muted">${extra.join("")}</div>` : "")
  );

  const abs = (d.abstract == null) ? "" : String(d.abstract).trim();
  const tldr = (d.tldr && typeof d.tldr === "object") ? String(d.tldr.text || "").trim() : "";
  const absHtml = abs ? escapeHtml(abs) : `<span class="muted">(no abstract)</span>`;
  const tldrHtml = tldr ? `<div style="margin-bottom:8px"><b>TL;DR:</b> ${escapeHtml(tldr)}</div>` : "";
  tAbs.innerHTML = tldrHtml + absHtml;

  tip.onclick = (ev) => {
    const el = ev.target;
    if (!el || typeof el.getAttribute !== "function") return;
    const open = el.getAttribute("data-open");
    if (open){
      ev.preventDefault();
      window.open(String(open), "_blank");
    }
  };

  // Fixed anchor: just below the Min edge pill (right side)
  tip.style.left = "auto";
  tip.style.right = "14px";

  const pill = document.querySelector("#topbar .pill");
  const pad = 10;

  if (pill){
    const r = pill.getBoundingClientRect();
    tip.style.top = Math.max(14, Math.round(r.bottom + pad)) + "px";
  }else{
    tip.style.top = "88px";
  }

  tip.style.display = "block";
}





  function togglePin(id){
    if (!id) return;
    if (pinned.has(id)){
      pinned.delete(id);
      toast("Unpinned.", 700);
    }else{
      pinned.add(id);
      toast("Pinned.", 700);
    }
    applyMode();
  }

  // ------------------------------------------------------------
  // FAST cytoscape build (Qt-focused)
  // ------------------------------------------------------------
  function setListModeButtons(mode){
  const bA = document.getElementById("lpAll");
  const bP = document.getElementById("lpPrior");
  const bD = document.getElementById("lpDeriv");
  if (bA) bA.classList.toggle("active", mode === "all");
  if (bP) bP.classList.toggle("active", mode === "prior");
  if (bD) bD.classList.toggle("active", mode === "derivative");
}

function listShouldIncludeId(id){
  const pid = String(id || "");
  if (!pid) return false;

  if (listMode === "prior") return (pid === String(payloadCache.seedId || "")) || priorSet.has(pid) || pinned.has(pid);
  if (listMode === "derivative") return (pid === String(payloadCache.seedId || "")) || derivSet.has(pid) || pinned.has(pid);
  return true;
}

function authorsToString(a){
  if (!a) return "";
  if (typeof a === "string") return a.trim();
  if (Array.isArray(a)){
    const out = [];
    for (const x of a){
      if (!x) continue;
      if (typeof x === "string") out.push(x.trim());
      else if (typeof x === "object" && x.name) out.push(String(x.name).trim());
    }
    return out.filter(Boolean).join(", ");
  }
  if (typeof a === "object" && a.name) return String(a.name).trim();
  return "";
}

function matchesFilter(d){
  const q = normalizeText(listFilter);
  if (!q) return true;
  const t = normalizeText(d._title || d.label);
  const a = normalizeText(authorsToString(d.authors));
  return t.includes(q) || a.includes(q);
}


function buildListItems(){
  const box = document.getElementById("lpList");
  if (!box) return;

  const nodes = payloadCache.nodes || [];
  const items = [];

  for (const n of nodes){
    const d = (n && n.data) ? n.data : null;
    if (!d) continue;
    const pid = String(d.id || "");
    if (!listShouldIncludeId(pid)) continue;
    if (!matchesFilter(d)) continue;

    // sort key: citations desc, then year desc
    const cites = safeInt(d.citations, 0);
    const year  = safeInt(d.year, 0);
    items.push({ d, cites, year, pid });
  }

  items.sort((a,b) => (b.cites - a.cites) || (b.year - a.year) || a.pid.localeCompare(b.pid));

  const html = items.map(({d,pid}) => {
    const title = String(d._title || d.label || pid || "Untitled");
    const authors = authorsToString(d.authors).split(",")[0].trim();
    const year = d.year ? String(d.year) : "n/a";
    const cites = safeInt(d.citations,0) ? `cites ${safeInt(d.citations,0)}` : "cites n/a";

    const flags = [];
    if (pid === String(payloadCache.seedId || "")) flags.push(`<span class="chip">SEED</span>`);
    if (priorSet.has(pid)) flags.push(`<span class="chip">PRIOR</span>`);
    if (derivSet.has(pid)) flags.push(`<span class="chip">DERIV</span>`);
    if (pinned.has(pid)) flags.push(`<span class="chip">PIN</span>`);

    const meta = [
      authors ? `<span class="chip gray">${authors}</span>` : `<span class="chip gray">author n/a</span>`,
      `<span class="chip gray">${year}</span>`,
      `<span class="chip gray">${cites}</span>`,
      ...flags
    ].join("");

    return `
      <div class="lpItem" data-id="${pid}" role="option" aria-selected="${pid === selectedId ? "true" : "false"}">
        <div class="lpRow1">
          <div class="lpMain" title="${title.replace(/"/g,'&quot;')}">${title}</div>
        </div>
        <div class="lpMeta">${meta}</div>
      </div>
    `;
  }).join("");

  box.innerHTML = html || `<div class="muted" style="padding:10px 8px;">No items.</div>`;

  // click handlers
// click handlers
box.querySelectorAll(".lpItem").forEach(el => {
  el.addEventListener("click", () => {
    const id = el.getAttribute("data-id") || "";
    if (!id) return;

    if (graphScope === "local") {
      _apply_scope_after_selection(id);

      window.setTimeout(() => {
        if (!cy) return;
        const n = cy.getElementById(String(id));
        if (!n || n.empty()) return;
        cy.animate({ center: { eles: n } }, { duration: 180 });
      }, 0);

      return;
    }

    selectNode(id, true);
  });
});

updateListSelection(selectedId);
}

function updateListSelection(id){
  const box = document.getElementById("lpList");
  if (!box) return;

  const sid = String(id || "");
  box.querySelectorAll(".lpItem").forEach(el => {
    const eid = el.getAttribute("data-id") || "";
    const isOn = (eid === sid);
    el.classList.toggle("active", isOn);
    el.setAttribute("aria-selected", isOn ? "true" : "false");
  });
}

function hookLeftPanel(){
  const left = document.getElementById("leftPanel");
  const btnToggle = document.getElementById("lpToggle");
  if (!left || !btnToggle) return;

  const svgPlay = `
    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
      <path d="M9 8l8 4-8 4V8z" stroke="currentColor" stroke-width="1.6" fill="none"></path>
    </svg>
  `;

  const svgChevron = `
    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
      <path d="M14 6l-6 6 6 6" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
  `;

  function sync(){
    const isCollapsed = left.classList.contains("collapsed");
    btnToggle.innerHTML = isCollapsed ? svgPlay : svgChevron;
    btnToggle.setAttribute("aria-label", isCollapsed ? "Open panel" : "Close panel");
    left.setAttribute("aria-expanded", isCollapsed ? "false" : "true");
  }

  function toggle(open){
    if (open === true) left.classList.remove("collapsed");
    else if (open === false) left.classList.add("collapsed");
    else left.classList.toggle("collapsed");
    sync();
  }

  btnToggle.addEventListener("click", (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
    toggle();
  });

  left.addEventListener("click", (ev) => {
    if (!left.classList.contains("collapsed")) return;
    const t = ev.target;
    if (t && t.closest && t.closest("#lpToggle")) return;
    toggle(true);
  });

  sync();
}



  function buildCytoscape(nodes, edges){
    if (typeof window.cytoscape !== "function"){
      uiError(true);
      toast("Cytoscape not loaded.", 1200);
      return null;
    }

    // Force faster default in Qt: COSE with smaller iteration budget.
    // You can re-enable cola/fcose later if you want, but they cost more.
const layoutPreferred = (window.layoutPreferred === "cola" || window.layoutPreferred === "fcose") ? window.layoutPreferred : "cose";

    function edgeLengthFromWeight(w){
      const t = clamp01(Number.isFinite(w) ? w : 0);
      return 200 - 70 * Math.pow(t, 1.05);
    }

    let layout;
    if (layoutPreferred === "cola"){
      layout = {
        name: "cola",
        fit: true,
        padding: 80,
        animate: false,
        randomize: false,
        nodeSpacing: 18,
        edgeLength: (e) => edgeLengthFromWeight(safeNum(e.data("weight"), 0)),
        unconstrIter: 6,
        userConstIter: 10,
        allConstIter: 12,
        maxSimulationTime: 900
      };
    }else if (layoutPreferred === "fcose"){
      layout = {
        name: "fcose",
        quality: "default",
        animate: false,
        fit: true,
        padding: 80,
        randomize: true,
        idealEdgeLength: (edge) => edgeLengthFromWeight(safeNum(edge.data("weight"), 0)),
        nodeRepulsion: 9000,
        edgeElasticity: 0.35,
        gravity: 0.04,
        numIter: 320,
        nodeSeparation: 18
      };
    }else{
      layout = {
        name: "cose",
        fit: true,
        padding: 80,
        animate: false,
        randomize: false,
        nodeRepulsion: 9000,
        idealEdgeLength: 175,
        edgeElasticity: 0.25,
        gravity: 0.06,
        nestingFactor: 1.2,
        numIter: 260
      };
    }

    // FAST style: keep premium look but reduce expensive paint work.
    // Labels are toggled off during viewport (pan/zoom) by .noLabel class.
    const style = [

  {
  selector: "node",
  style: {
    "width": (ele) => {
      const c = safeInt(ele.data("citations"), 0);
      const s = 22 + Math.log10(1 + Math.max(0, c)) * 14;
      return Math.max(28, Math.min(s, 84));
    },
    "height": (ele) => {
      const c = safeInt(ele.data("citations"), 0);
      const s = 22 + Math.log10(1 + Math.max(0, c)) * 14;
      return Math.max(28, Math.min(s, 84));
    },

    "background-fill": "solid",
    "background-color": (ele) => String(ele.data("_baseColor") || "#e5e7eb"),

    "border-color": (ele) => yearColor(ele.data("year")),
    "border-width": 1.3,
    "border-opacity": 0.62,


"background-image": "data(avatar)",
"background-fit": "none",
"background-clip": "node",
"background-repeat": "no-repeat",
"background-position-x": "50%",
"background-position-y": "50%",
"background-width": "55%",
"background-height": "55%",
"background-image-opacity": 0.22,


    "label": (ele) => {
      const a = authorsToString(ele.data("authors"));
      const fa = a ? a.split(",")[0].trim() : "";
      const y = safeInt(ele.data("year"), 0);
      return fa ? (y ? `${fa} (${y})` : fa) : String(ele.data("label") || ele.id());
    },

    "font-size": 12,
    "font-weight": 600,
    "color": "#0f172a",
    "text-wrap": "wrap",
    "text-max-width": 210,
    "text-valign": "center",
    "text-halign": "center",

    "text-background-color": "#ffffff",
    "text-background-opacity": 0.88,
    "text-background-shape": "roundrectangle",
    "text-background-padding": 3
  }
},


      {
        selector: "node.noLabel",
        style: {
          "label": "",
          "text-background-opacity": 0
        }
      },

{
  selector: "node[isSeed]",
  style: {
    "border-color": "#111827",
    "border-width": 4,
    "border-opacity": 0.95,
    "border-style": "double"
  }
},

{ selector: "node.hoverNode", style: {
    "border-width": 4,
    "border-opacity": 0.98,
    "border-style": "solid"
  }
},


      {
        selector: "edge",
        style: {
          "curve-style": "bezier",
          "line-cap": "round",
          "line-color": "rgba(100,116,139,0.34)",
          "width": (ele) => {
            const w = safeNum(ele.data("weight"), 0);
            const t = clamp01(w);
            return 0.7 + 2.4 * Math.pow(t, 1.15);
          },
          "opacity": (ele) => {
            const w = safeNum(ele.data("weight"), 0);
            const t = clamp01(w);
            return 0.10 + 0.60 * Math.pow(t, 1.3);
          }
        }
      },

      // premium hover spotlight
      { selector: "node.hoverNode", style: {
    "border-width": 3.0,
    "border-opacity": 0.95,

    "underlay-color": "rgba(37,99,235,0.18)",
    "underlay-padding": 12,
    "underlay-opacity": 1.0
  }
},
{ selector: "edge.hoverEdge", style: {
    "opacity": 0.88,
    "width": (ele) => Math.max(1.2, safeNum(ele.style("width"), 1.2) * 1.3)
  }
},

      // dimming
      { selector: ".dim", style: { "opacity": 0.12 } },
      { selector: "edge.dim", style: { "opacity": 0.06 } }
    ];

    try{
      uiError(false);

      const instance = cytoscape({
        container: document.getElementById("cy"),
        renderer: { name: "canvas" },
        elements: (nodes || []).concat(edges || []),
        selectionType: "single",
        wheelSensitivity: 0.22,

        // BIG Qt speed win
        pixelRatio: 1,

        // keep interaction responsive during pan/zoom
        textureOnViewport: true,

        style: style,
        layout: layout
      });

      // layout UX
      instance.on("layoutstart", () => setLoading(true, "Layout…"));
      instance.on("layoutstop",  () => setLoading(false, ""));

      return instance;
    }catch(e){
      uiError(true);
      console.log("Cytoscape init failed:", e);
      return null;
    }
  }

function clearSelection(){
  selectedId = "";
  if (cy) cy.nodes().unselect();
  updateTip(null);
  updateListSelection("");
}

  function selectNode(id, fromList){
    if (!id) return;
    selectedId = String(id);

    const d = pickNodeDataById(selectedId);
    updateTip(d);
    updateListSelection(selectedId);


    if (cy){
      const n = cy.getElementById(selectedId);
      if (n && !n.empty()){
        cy.nodes().unselect();
        n.select();

        spotlightNode(n);

        if (fromList){
          cy.animate({ center: { eles: n } }, { duration: 180 });
        }
      }
    }
  }

  function bindCyEvents(){
    if (!cy) return;

    // Clear on background click
    cy.on("tap", (evt) => {
  if (evt.target === cy){
    clearSelection();
    clearSpotlight();
    applyMode();
    return;
  }
});

    cy.on("zoom", () => {
  if (!cy) return;
  const z = cy.zoom();
  cy.batch(() => {
    cy.nodes().forEach(n => {
      // hide labels when zoomed out, show when zoomed in
      n.toggleClass("noLabel", z < 0.85);
    });
  });
});

    // Click select + lock spotlight
// Click select + lock spotlight
let _lastTapNodeId = "";
let _lastTapAt = 0;

cy.on("tap", "node", (evt) => {
  const n = evt.target;
  if (!n) return;

  const now = Date.now();
  const idNow = String(n.id());
  const isDouble = (idNow === _lastTapNodeId) && (now - _lastTapAt <= 340);
  _lastTapNodeId = idNow;
  _lastTapAt = now;

  selectedId = idNow;
  const d = pickNodeDataById(selectedId);

  if (cy) {
    cy.nodes().unselect();
    n.select();
  }

  spotlightNode(n);
  updateListSelection(selectedId);
  updateTip(d);  // fixed-position tooltip version you added earlier

  if (isDouble) {
    const url = d ? String(d.url || "") : "";
    if (url) {
      try { window.open(url, "_blank", "noopener,noreferrer"); } catch (_) {}
      toast("Opened paper URL.", 800);
    } else {
      toast("No URL for this node.", 900);
    }
  }

  console.log("NODE_CLICK:" + n.id());
});

// Right click pin/unpin
cy.on("cxttap", "node", (evt) => {
  const n = evt.target;
  if (!n) return;

  const pid = String(n.id() || "");
  togglePin(pid);
  updateListSelection(pid);
  updateTip(pickNodeDataById(pid));
});

//

    // Hover spotlight (only when nothing is selected)
    cy.on("mouseover", "node", (evt) => {
      if (!cy) return;
      if (selectedId) return; // keep selection spotlight
      spotlightNode(evt.target);
      cy.container().style.cursor = "pointer";
    });

    cy.on("mouseout", "node", () => {
      if (!cy) return;
      if (selectedId) return;
      clearSpotlight();
      applyMode(); // re-apply mode dimming after hover clears
      cy.container().style.cursor = "default";
    });

    cy.on("mouseover", "edge", (evt) => {
      if (!cy) return;
      if (selectedId) return;
      spotlightEdge(evt.target);
      cy.container().style.cursor = "pointer";
    });

    cy.on("mouseout", "edge", () => {
      if (!cy) return;
      if (selectedId) return;
      clearSpotlight();
      applyMode();
      cy.container().style.cursor = "default";
    });

    // Viewport: hide labels while pan/zoom (major Qt win)
    cy.on("viewport", () => {
      if (!cy) return;

      if (!_isViewportBusy){
        _isViewportBusy = true;
        cy.batch(() => cy.nodes().addClass("noLabel"));
      }

      window.clearTimeout(_viewportTimer);
      _viewportTimer = window.setTimeout(() => {
        _isViewportBusy = false;
        if (!cy) return;
        cy.batch(() => cy.nodes().removeClass("noLabel"));
      }, 140);
    });
  }

function fitView(){
  if (!cy) return;
  cy.fit(cy.elements(":visible"), 70);
  cy.center(cy.elements(":visible"));
  toast("Fit view.", 700);
}

let _autoFitTimer = 0;

function requestAutoFit(){
  if (!cy) return;
  window.clearTimeout(_autoFitTimer);
  _autoFitTimer = window.setTimeout(() => {
    if (!cy) return;
    try{
      const vis = cy.elements(":visible");
      cy.resize();
      cy.fit(vis, 70);
      cy.center(vis);
    }catch(_){}
  }, 140);
}

function installAutoFitOnResize(){
  window.addEventListener("resize", () => requestAutoFit());
  document.addEventListener("fullscreenchange", () => requestAutoFit());
}

function relayout(){
    if (!cy) return;

    const els = cy.elements(":visible");
    const name = (window.layoutPreferred || "cola");

    const opts = (name === "cola")
        ? { name:"cola", animate:true, maxSimulationTime: 1500, nodeSpacing: 10, edgeLengthVal: 55 }
        : (name === "fcose")
            ? { name:"fcose", animate:true, randomize:false, quality:"default", nodeSeparation: 90, idealEdgeLength: 80 }
            : { name:"cose", animate:true, padding: 30 };

toast(`Re-layout (${name})`, 900);

    try{
        const l = els.layout(opts);
        l.on("layoutstop", function(){
            try{
                cy.fit(cy.elements(":visible"), 70);
                cy.center(cy.elements(":visible"));
            }catch(_){}
        });
        l.run();
    }catch(e){
        console.warn("[layout] failed", e);
        try{
            const l2 = els.layout({name:"cose", animate:true, padding: 30});
            l2.on("layoutstop", function(){
                try{
                    cy.fit(cy.elements(":visible"), 70);
                    cy.center(cy.elements(":visible"));
                }catch(_){}
            });
            l2.run();
        }catch(_){}
    }
}


  function performSearch(q){
    if (!cy) return;
    const query = normalizeText(q);
    if (!query){
      lastSearchHits = [];
      lastSearchIndex = -1;
      toast("Empty search.", 900);
      return;
    }

    const hits = [];
    cy.nodes().forEach(n => {
      const label = normalizeText(n.data("label"));
      const authors = normalizeText(authorsToString(n.data("authors")));
      if (label.includes(query) || authors.includes(query)) hits.push(n.id());
    });

    lastSearchHits = hits;
    lastSearchIndex = -1;

    if (!hits.length){
      toast("No matches.", 900);
      return;
    }

    toast(`Found ${hits.length} match(es). Press Enter to jump.`, 1200);
    jumpToNextSearchHit();
  }

  function jumpToNextSearchHit(){
    if (!lastSearchHits.length) return;
    lastSearchIndex = (lastSearchIndex + 1) % lastSearchHits.length;
    selectNode(lastSearchHits[lastSearchIndex], true);
  }

  function clearFocus(){
    lastSearchHits = [];
    lastSearchIndex = -1;
  }

  function setMode(mode){
    currentMode = (mode === "prior" || mode === "derivative") ? mode : "all";
    setModeButtons(currentMode);
    applyMode();
    toast(`Mode: ${currentMode}`, 700);
  }

  function exportPng(){
    if (!cy) return;

    try{
      // keep scale moderate for speed
      const png64 = cy.png({ full: true, scale: 2, bg: "#ffffff" });

      if (window.qtBridge && typeof window.qtBridge.savePngDataUrl === "function"){
        window.qtBridge.savePngDataUrl(png64);
        toast("Export requested.", 900);
        return;
      }

      const a = document.createElement("a");
      a.href = png64;
      a.download = "graph.png";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      toast("Downloaded graph.png", 900);
    }catch(e){
      toast("Export failed.", 900);
      console.log("exportPng failed:", e);
    }
  }

  function resetUi(){
    pinned.clear();
    selectedId = "";
    clearSelection();
    clearFocus();
    setMode("all");
    if (cy){
      cy.batch(() => {
        cy.nodes().removeClass("dim hoverNode noLabel");
        cy.edges().removeClass("dim hoverEdge");
      });
      cy.fit(undefined, 70);
    }
    toast("Reset.", 700);
  }
  function toggleFullscreen(){
  const root = document.getElementById("graphWrap") || document.documentElement;

  const isFs = !!document.fullscreenElement;
  if (isFs){
    if (document.exitFullscreen) document.exitFullscreen();
    return;
  }

  if (root && root.requestFullscreen){
    root.requestFullscreen().catch(() => {
      toast("Fullscreen blocked by host settings.", 1200);
    });
  }else{
    toast("Fullscreen not supported.", 1200);
  }
}

document.addEventListener("fullscreenchange", () => {
  requestAutoFit();
});

function hookUi(){
  const qs = (id) => document.getElementById(id);

  const btnFit    = qs("btnFit");
  const btnRel    = qs("btnRelayout");
  const btnAll    = qs("btnAll");
  const btnPrior  = qs("btnPrior");
  const btnDeriv  = qs("btnDeriv");
  const btnScope  = qs("btnScope");
  const btnPng    = qs("btnExportPng");
  const btnReset  = qs("btnReset");
  const btnFs     = qs("btnFullscreen");

  if (btnFit)   btnFit.addEventListener("click", () => fitView());
  if (btnRel)   btnRel.addEventListener("click", () => relayout());
  if (btnAll)   btnAll.addEventListener("click", () => setMode("all"));
  if (btnPrior) btnPrior.addEventListener("click", () => setMode("prior"));
  if (btnDeriv) btnDeriv.addEventListener("click", () => setMode("derivative"));
  if (btnPng)   btnPng.addEventListener("click", () => exportPng());
  if (btnReset) btnReset.addEventListener("click", () => resetUi());

  if (btnScope){
    btnScope.addEventListener("click", () => {
      const next = (graphScope === "global") ? "local" : "global";
      setScope(next);
    });
  }

  if (btnFs){
    btnFs.addEventListener("click", (ev) => {
      ev.preventDefault();
      toggleFullscreen();
    });
  }

  hookLeftPanel();
}

window.addEventListener("keydown", (e) => {
  const t = e.target;
  const tag = t && t.tagName ? String(t.tagName).toLowerCase() : "";
  const isTyping = (tag === "input" || tag === "textarea" || (t && t.isContentEditable === true));
  if (isTyping) return;

  if (e.key === "F11"){
    e.preventDefault();
    toggleFullscreen();
  }
});



  const sIn = document.getElementById("searchInput");
  const bSearch = document.getElementById("btnSearch");
  const bClear = document.getElementById("btnClearSearch");

  if (bSearch && sIn) bSearch.onclick = () => performSearch(sIn.value);
  if (bClear && sIn) bClear.onclick = () => {
    sIn.value = "";
    clearFocus();
    toast("Cleared.", 700);
  };

  if (sIn){
    sIn.addEventListener("keydown", (e) => {
      if (e.key === "Enter"){
        if (normalizeText(sIn.value) && lastSearchHits.length) jumpToNextSearchHit();
        else performSearch(sIn.value);
        e.preventDefault();
      }
      if (e.key === "Escape"){
        sIn.value = "";
        clearFocus();
        toast("Search cleared.", 700);
      }
    });
  }
window.addEventListener("keydown", (e) => {
  const t = e.target;
  const tag = t && t.tagName ? String(t.tagName).toLowerCase() : "";
  const isTyping = (tag === "input" || tag === "textarea" || (t && t.isContentEditable === true));

  if (isTyping){
    if (e.key === "Escape"){
      selectedId = "";
      clearSelection();
      clearSpotlight();
      applyMode();
      clearFocus();
      toast("Cleared selection.", 700);
    }
    return;
  }

  if (e.key === "/"){
    if (sIn) sIn.focus();
    e.preventDefault();
    return;
  }

  if (e.key === "Escape"){
    selectedId = "";
    clearSelection();
    clearSpotlight();
    applyMode();
    clearFocus();
    toast("Cleared selection.", 700);
    return;
  }

  if (e.key === "f" || e.key === "F"){ fitView(); return; }
  if (e.key === "r" || e.key === "R"){ relayout(); return; }
  if (e.key === "e" || e.key === "E"){ exportPng(); return; }
  if (e.key === "a" || e.key === "A"){ setMode("all"); return; }
  if (e.key === "p" || e.key === "P"){ setMode("prior"); return; }
  if (e.key === "d" || e.key === "D"){ setMode("derivative"); return; }

  if (e.key === "g" || e.key === "G"){
    const bScope = document.getElementById("btnScope");
    if (bScope) bScope.click();
    return;
  }
});
function render(payload){
  payloadCache = payload || {};
  _rebuild_sets_from_payload(payloadCache);

  const nodes = payloadCache.nodes || [];
  const edges = payloadCache.edges || [];

  // Ensure every node has a deterministic base color + avatar.
  for (const n of nodes){
    const d = (n && n.data) ? n.data : null;
    if (!d) continue;

    if (!d._baseColor){
      d._baseColor = pickNodeBaseColor(d);
    }

    if (!d.avatar){
      const a0 = firstAuthorName(authorsToString(d.authors));
      const init = initialsFromName(a0);
      d.avatar = svgAvatarDataUri(init, d._baseColor);
    }
  }

  if (typeof updateYearLegendFromNodes === "function"){
    updateYearLegendFromNodes(nodes);
  }
  setStats(buildStats(payloadCache));

  if (cy){
    try{ cy.destroy(); }catch(_){}
    cy = null;
  }

  pinned.clear();
  selectedId = "";
  lastSearchHits = [];
  lastSearchIndex = -1;

  updateTip(null);
  updateListSelection("");

  setLoading(true, "Rendering graph…");
  cy = buildCytoscape(nodes, edges);
  setLoading(false);

  if (!cy) return;

  bindCyEvents();
  setModeButtons(currentMode);
  applyMode();

  cy.one("layoutstop", () => {
    try{ cy.fit(cy.elements(":visible"), 70); }catch(_){}
  });
  try{ cy.fit(cy.elements(":visible"), 70); }catch(_){}

  buildListItems();

  const seedId = payloadCache.seedId ? String(payloadCache.seedId) : "";
  console.log("GRAPH_READY:" + seedId);
  toast("Graph ready.", 900);

  clearSelection();
}



function handleMessage(msg){
  if (!msg || typeof msg !== "object") return;

  if (msg.type === "updateGraph"){
    const p = msg.payload || {};
    payloadCacheFull = p;
    render(p);

    if (graphScope === "local" && selectedId){
      _apply_scope_after_selection(selectedId);
    }
    return;
  }

  if (msg.type === "setMode"){
    const mode = (msg.payload || {}).mode || "all";
    setMode(mode);
    return;
  }

  if (msg.type === "selectNode"){
    const id = (msg.payload || {}).id || "";
    if (!id) return;

    if (graphScope === "local"){
      _apply_scope_after_selection(id);
      return;
    }

    selectNode(id, true);
    return;
  }
}


window.addEventListener("message", (event) => {
  handleMessage(event.data);
}, false);

(function init(){
  graphScope = loadScope();

  if (typeof connectQtBridge === "function") connectQtBridge();
  if (typeof registerExtensions === "function") registerExtensions();

  hookUi();
  setModeButtons("all");

  setScopeUi(graphScope);
  installAutoFitOnResize();

  if (typeof updateTip === "function") updateTip(null);
  if (typeof setLoading === "function") setLoading(false, "");

  // Keep graph fitted and centred when the viewport changes (fullscreen, detach, resize)
  (function hookResizeFit(){
    let t = 0;

    function doFit(){
      if (!cy) return;
      try{
        cy.resize();
        const vis = cy.elements(":visible");
        cy.fit(vis, 70);
        cy.center(vis);
      }catch(_){}
    }

    function scheduleFit(){
      window.clearTimeout(t);
      t = window.setTimeout(doFit, 120);
    }

    window.addEventListener("resize", scheduleFit, { passive: true });

    const host = document.getElementById("graphWrap") || document.getElementById("cy");
    if (host && typeof ResizeObserver === "function"){
      const ro = new ResizeObserver(() => scheduleFit());
      ro.observe(host);
    }
  })();
})();



</script>


  </div> <!-- end #app -->
</body>
</html>
